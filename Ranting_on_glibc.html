<!DOCTYPE html>
<html>

<head>
    <meta property="article:published_time" content="2022-12-15T21:21:12.000Z" />
</head>

<body>
    <main>
        <article>
            <section>
                <div class="pw-post-title">
                    <h1>Ranting on glibc</h1>
                </div>
                <p class="pw-post-body-paragraph">
                    Friday evening rant
                </p>
                <p class="pw-post-body-paragraph">
                   There is a library called glibc, whose authors are known for wanting to make everything "better" than others.<br>
                   The problem is that their solutions often turn out to be just "different", and then it's like - "Fuck, who came up with this and why".
                </p>
                <p class="pw-post-body-paragraph">
                    There is such a function - pthread_cancel().
                </p>
                <p class="pw-post-body-paragraph">
                    Do not use it, anywhere, ever. Its behavior is poorly defined and in real life, it will lead you to some kind of deadlock. 
                    Because you won’t write tests for this section of code anyway.
                </p>
                <p class="pw-post-body-paragraph">
                    According to the standard, all it should do is call specially registered cleanup handlers and terminate the thread. 
                    But colleagues from glibc decided that this was not enough! And they added the following feature - they call the stack unwinder 
                    to destroy local objects on the stack in this thread.
                </p>
                <p class="pw-post-body-paragraph">
                    I've been thinking for a while about how to solve the most problems that annoy me with the least effort.
                </p>
                <p class="pw-post-body-paragraph">
                    Write my own OS? I get trolled about it approximately once a month. By the way, I think I could create a good OS 
                    (someday I need to write about how it would be designed). The only problem is that it may take me about 15 years to be able 
                    to run a currently modern graphical application on it, and that's only if I don’t mess up the architecture and tools too much.
                </p>
                <p class="pw-post-body-paragraph">
                    I imagine this quite accurately. You can just look at the dynamics of Linux development and extrapolate it based on:
                </p>
                <ul>
                <li>Using a normal programming language to write 10 times faster than Linux developers do;</li>
                <li>Applying normal architectural practices for kernel development.</li> 
                </ul>                
                <p class="pw-post-body-paragraph">
                    Figures on the size of the kernel 
                    <a href="https://www.opennet.ru/opennews/art.shtml?num=57260">https://www.opennet.ru/opennews/art.shtml?num=57260</a>.
                </p>
                <p class="pw-post-body-paragraph">
                    I roughly understand that Linux became normal around version 2.6, with 5-10 MLOC. If we use a proper language, we need to write 
                    somewhere between 0.5-1 MLOC.<br>
                    In general, everything is predictable and very sad.                
                </p>
                <p class="pw-post-body-paragraph">
                    As a result, I decided that most of my problems could be solved by a normal Linux distribution that I understand well and can customize to fit my needs.
                </p>
                <p class="pw-post-body-paragraph">
                    For example, I can create a daemon that kills all orphaned processes inherited by init gradually and incrementally.<br>
                    Additionally, I can abandon dynamic linking and DLL hell as a class of problems.
                </p>
                <p class="pw-post-body-paragraph">
                    To implement these on the same Fedora - it’s easier to kill myself.
                </p>
                <p class="pw-post-body-paragraph">
                    About the overall complexity of the system and how I try to fight with it - well, that's basically what my whole blog is about.
                </p>
                <p class="pw-post-body-paragraph">
                    From all of the above, it follows that:
                </p>
                <ul>
                <li>it is completely pointless to ask me "why not systemd",</li>
                <li>"why not ostree",</li>
                <li>"why …".</li>
                </ul> 
                <p class="pw-post-body-paragraph">
                    I'm trying to solve the problems I know in a different way. This is an exploratory hobby distribution, and not a competitor to RHEL in its field.<br>
                    If I'm satisfied with systemd and DLL hell, I'll choose Fedora and not worry.
                </p>
                <p class="pw-post-body-paragraph">
                    But I am interested in "how, in general, can it be done differently."                
                </p>
                
          </section>
        </article>
    </main>
</body>

</html>

