<!DOCTYPE html>
<html>

<head>
    <meta property="article:published_time" content="2023-03-07T16:24:17.000Z" />
</head>

<body>
    <main>
        <article>
            <section>
                <div class="pw-post-title">
                    <h1>Developed a portal for Mesa update</h1>
                </div>
                <p class="pw-post-body-paragraph">
                    I am being asked why I decided to create my own portal.<br>
                    Here's the story.
                </p>
                <p class="pw-post-body-paragraph">
                    About xdg-open, first
                </p>
                <p class="pw-post-body-paragraph">
                    For a reasonable Linux application, there are two ways to open an external relative to itself file:
                </p>
                <p class="pw-post-body-paragraph">
                <ol>
                <li>Call the portal via D-Bus.</li>
                <li>Call the command line tool xdg-open, passing it the path to the file or URL.</li>
                </ol>                
                </p>
                <p class="pw-post-body-paragraph">
                    It is assumed that each DE will provide its own portal or its own xdg-open script.<br> 
                    (I'm simplifying a bit here for ease of explanation.)
                </p>                
                <p class="pw-post-body-paragraph">
                    Unfortunately, in the wild I only found the implementation from freedesktop, and I disliked it so much that when trying to describe it, only swear words remain
                    <a href="https://www.freedesktop.org/wiki/Software/xdg-utils/">https://www.freedesktop.org/wiki/Software/xdg-utils/</a>.
                </p>
                <p class="pw-post-body-paragraph">
                    (By the way, insane applications also have other paths. For example, KDE-lovers are high from KParts (ab)using, but this is not about that.)
                </p>
                <p class="pw-post-body-paragraph">
                    For some time, I had a stub for xdg-open that just opened everything in the browser -
                    <a href="https://github.com/pg83/ix/blob/99291c90267d7b690bc39fca7224c0a20b76334c/pkgs/bin/xdg/open/ix.sh#L">https://github.com/pg83/ix/blob/99291c90267d7b690bc39fca7224c0a20b76334c/pkgs/bin/xdg/open/ix.sh#L</a>.
                </p>
                <p class="pw-post-body-paragraph">
                    The browser can open almost everything, and that solved 90% of my problems.
                </p>
                <p class="pw-post-body-paragraph">
                    On the one hand, it is somewhat embarrassing to give people such a solution, but on the other hand, I didnâ€™t want to violence my brain with freedesktop's xdg-open.
                </p>
                <p class="pw-post-body-paragraph">
                    So I decided to use my knowledge of what binaries I have in my distribution and wrote this script - 
                    <a href="https://github.com/pg83/ix/blob/main/pkgs/bin/xdg/open/scripts/xdg-open">https://github.com/pg83/ix/blob/main/pkgs/bin/xdg/open/scripts/xdg-open</a>.                
                </p>                
                <ul>
                <li><a href="https://github.com/pg83/ix/blob/main/pkgs/set/ci/unwrap/ix.sh">https://github.com/pg83/ix/blob/main/pkgs/set/ci/unwrap/ix.sh</a> 
                    - cheap auto-build and CI for other platforms. Adding AArch64 to auto-build only took two lines in the build files.<br>
                    <a href="https://github.com/pg83/ix/blob/main/pkgs/set/ci/unwrap/linux/aarch64/ix.sh">https://github.com/pg83/ix/blob/main/pkgs/set/ci/unwrap/linux/aarch64/ix.sh</a> 
                    - the list of what I regularly build for AArch64 including GDB and even graphical programs!</li>
                <li>New possibilities for bootstrapping. For example, Go is currently not reproducible in terms of classic methods (package managers and build systems), 
                    because the latest version of Go compiled with a C compiler cannot build code for M1 and cannot be compiled on it. 
                    Now I can approach this problem by writing something like this in the Go build file:</li>
                </ul>                
                <ol>
                <li>Complex security models do not "compose" well, and end up being poorly interacting. Like selinux + cgroups;</li>
                <li>The more complex the system, the harder it is to think about it for a leatherbag.</li>
                </ol>                
                <p class="pw-post-body-paragraph">
                    Therefore, I believe that "all-or-nothing" type models rule due to their simplicity - it is harder to mess up in their implementation, 
                    and they are easier to think about. And despite the fact that they cannot express various crap complex policies, they turn out to be safer.
                </p>
                <p class="pw-post-body-paragraph">
                    How to deal with inherent complexity? I believe that through hierarchy - the top level is divided into two "all/nothing" layers. 
                    Within each layer you can run a container with the same simple division.                
                </p>
          </section>
        </article>
    </main>
</body>

</html>
