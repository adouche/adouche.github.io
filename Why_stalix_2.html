
<!DOCTYPE html>
<html>

<head>
    <meta property="article:published_time" content="2022-05-28T19:39:49.000Z" />
</head>

<body>
    <main>
        <article>
            <section>
                <div class="pw-post-title">
                    <h1>Why stal/IX. Part 2</h1>
                </div>
                <p class="pw-post-body-paragraph">
                    Prereq: Part 1
                </p>
                <p class="pw-post-body-paragraph">
                    Many times I promised to write about why I created my own Linux distribution and why it is designed this way.
                </p>
                <p class="pw-post-body-paragraph">
                   Part two: Why this way and not another
                </p>
                <p class="pw-post-body-paragraph">
                    Directory structure
                </p>
                <p class="pw-post-body-paragraph">
                    Here everything is pretty simple. I don’t understand how one can create a new distribution based on
                    <a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">LSB/FHS</a> nowadays.                
                </p>
                <p class="pw-post-body-paragraph">
                    This is some kind of creepy legacy that has remained since the beginning of Unix, with a bunch of poorly solvable problems 
                    (DLL hell, atomic updates (ostree is a hack, don't argue otherwise)).                
                </p>
                <p class="pw-post-body-paragraph">
                    The FS should be a content addressable storage, similar to Git/Nix/Guix.                
                </p>
                <p class="pw-post-body-paragraph">
                    This provides us with almost free benefits, just to name a few:                
                </p>
                <ul>
                <li>Multi-versioning.</li>
                <li>Fast rollbacks and updates.</li>
                <li>Atomic updates (switching the entire configuration - switching 1 symlink).</li>
                <li>Free caching of build artifacts in the package system.</li>
                <li>Non-root/user package management. This is a direct consequence of content addressable storage.</li>
                </ul>
                <p class="pw-post-body-paragraph">
                    Functional configuration management
                </p>
                <p class="pw-post-body-paragraph">
                    This refers to the fact that the contents of etc/ are actually determined by a set of realm settings and a description of the package base.<br>
                    You can’t manually edit etc/, it is generated by realm preparation scripts and is read-only.
                </p>
                <p class="pw-post-body-paragraph">
                    I won’t write much here, those who know will understand, and I won’t be able to explain it in two sentences anyway.
                </p>
                <p class="pw-post-body-paragraph">
                    I imagine this quite accurately. You can just look at the dynamics of Linux development and extrapolate it based on:
                </p>
                <ul>
                <li>Using a normal programming language to write 10 times faster than Linux developers do;</li>
                <li>Applying normal architectural practices for kernel development.</li> 
                </ul>                
                <p class="pw-post-body-paragraph">
                    Figures on the size of the kernel 
                    <a href="https://www.opennet.ru/opennews/art.shtml?num=57260">https://www.opennet.ru/opennews/art.shtml?num=57260</a>.
                </p>
                <p class="pw-post-body-paragraph">
                    I roughly understand that Linux became normal around version 2.6, with 5-10 MLOC. If we use a proper language, we need to write 
                    somewhere between 0.5-1 MLOC.<br>
                    In general, everything is predictable and very sad.                
                </p>
                <p class="pw-post-body-paragraph">
                    As a result, I decided that most of my problems could be solved by a normal Linux distribution that I understand well and can customize to fit my needs.
                </p>
                <p class="pw-post-body-paragraph">
                    For example, I can create a daemon that kills all orphaned processes inherited by init gradually and incrementally.<br>
                    Additionally, I can abandon dynamic linking and DLL hell as a class of problems.
                </p>
                <p class="pw-post-body-paragraph">
                    To implement these on the same Fedora - it’s easier to kill myself.
                </p>
                <p class="pw-post-body-paragraph">
                    About the overall complexity of the system and how I try to fight with it - well, that's basically what my whole blog is about.
                </p>
                <p class="pw-post-body-paragraph">
                    From all of the above, it follows that:
                </p>
                <ul>
                <li>it is completely pointless to ask me "why not systemd",</li>
                <li>"why not ostree",</li>
                <li>"why …".</li>
                </ul> 
                <p class="pw-post-body-paragraph">
                    I'm trying to solve the problems I know in a different way. This is an exploratory hobby distribution, and not a competitor to RHEL in its field.<br>
                    If I'm satisfied with systemd and DLL hell, I'll choose Fedora and not worry.
                </p>
                <p class="pw-post-body-paragraph">
                    But I am interested in "how, in general, can it be done differently."                
                </p>
                
          </section>
        </article>
    </main>
</body>

</html>
